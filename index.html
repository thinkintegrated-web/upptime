<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Status Dashboard</title>
  <style>
    :root { --bg:#fafafa; --text:#222; --card:#fff; --br:#e3e6ea; --hdr:#f6f7f9; }
    body { font-family: system-ui, sans-serif; margin: 2rem; background: var(--bg); color: var(--text); }
    .sites-header { display:grid; grid-template-columns:1.6fr .6fr .6fr .8fr; gap:.75rem;
      padding:.75rem 1rem; font-weight:600; background:var(--hdr); border:1px solid var(--br);
      border-radius:.5rem; margin:1rem 0 .75rem; }
    .sites { display:grid; grid-template-columns:repeat(auto-fit,minmax(320px,1fr)); gap:.75rem; }
    .site-card { display:grid; grid-template-columns:1.6fr .6fr .6fr .8fr; gap:.75rem; align-items:center;
      padding:1rem; border:1px solid var(--br); border-radius:.75rem; background:var(--card); }
    .site-card .url { display:flex; align-items:center; gap:.5rem; }
    .pill { padding:.2rem .5rem; border-radius:999px; font-size:.875rem; }
    .pill.up { background:#e8f7ee; color:#207d41; }
    .pill.down { background:#fde8e8; color:#b42318; }
    .empty { margin-top:1rem; padding:1rem; background:#fff8db; border:1px solid #ffe08a; border-radius:.5rem; }
  </style>
</head>
<body>

  <header class="sites-header">
    <div>URL</div><div>Status</div><div>Response</div><div>Uptime</div>
  </header>

  <section id="sites" class="sites"></section>
  <div id="empty" class="empty" style="display:none">
    No public summary found yet. Once GitHub Pages publishes <code>history/summary.json</code>, this dashboard will populate automatically.
  </div>

  <script>
    // Resolve summary.json RELATIVE to wherever this page is served (handles /, /uptime/, etc.)
    const summaryUrl = new URL('history/summary.json', location.href).href;

    // Quiet fetch: returns null on failure (no 404 noise)
    async function fetchJsonQuiet(url) {
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) return null;
        return await res.json();
      } catch { return null; }
    }

    function pill(isUp) {
      const s = document.createElement('span');
      s.className = 'pill ' + (isUp ? 'up' : 'down');
      s.textContent = isUp ? 'Up' : 'Down';
      return s;
    }

    function renderCard(container, row) {
      const el = document.createElement('article');
      el.className = 'site-card';

      const url = document.createElement('div');
      url.className = 'url';
      const fav = document.createElement('img'); fav.height = 13; fav.alt = '';
      const link = document.createElement('a');
      const href = row.url || row.site || '';
      if (href) {
        try { fav.src = 'https://icons.duckduckgo.com/ip3/' + new URL(href).host + '.ico'; } catch {}
        link.href = href;
      }
      link.textContent = row.name || row.title || row.slug || href || '—';
      url.append(fav, link);

      const status = document.createElement('div'); status.className = 'status';
      const s = String(row.status || '').toLowerCase();
      if (s === 'up' || s === 'down') status.appendChild(pill(s === 'up')); else status.textContent = '—';

      const response = document.createElement('div'); response.className = 'response';
      const r = typeof row.responseTime === 'number' ? Math.round(row.responseTime) : null;
      response.textContent = (r != null && isFinite(r)) ? `${r} ms` : '—';

      const uptime = document.createElement('div'); uptime.className = 'uptime';
      const u = typeof row.uptime === 'number' ? row.uptime : null;
      uptime.textContent = (u != null && isFinite(u)) ? `${u.toFixed(2)}%` : '—';

      el.append(url, status, response, uptime);
      container.appendChild(el);
    }

    (async function init() {
      const list = document.getElementById('sites');
      const empty = document.getElementById('empty');

      // Only one fetch to a known public path; no raw/github-api calls = no 404 spam
      const summary = await fetchJsonQuiet(summaryUrl);
      if (!summary) { empty.style.display = 'block'; return; }

      const rows = Array.isArray(summary) ? summary : (summary.sites || []);
      if (!rows.length) { empty.style.display = 'block'; return; }

      rows.forEach(renderCard.bind(null, list));
    })();
  </script>
</body>
</html>
