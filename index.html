<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Status Dashboard</title>
  <style>
    :root { --bg:#fafafa; --text:#222; --card:#fff; --br:#e3e6ea; --hdr:#f6f7f9; }
    body { font-family: system-ui, sans-serif; margin: 2rem; background: var(--bg); color: var(--text); }
    .sites-header { display:grid; grid-template-columns:1.6fr .6fr .6fr .8fr; gap:.75rem;
      padding:.75rem 1rem; font-weight:600; background:var(--hdr); border:1px solid var(--br);
      border-radius:.5rem; margin:1rem 0 .75rem; }
    .sites { display:grid; grid-template-columns:repeat(auto-fit,minmax(320px,1fr)); gap:.75rem; }
    .site-card { display:grid; grid-template-columns:1.6fr .6fr .6fr .8fr; gap:.75rem; align-items:center;
      padding:1rem; border:1px solid var(--br); border-radius:.75rem; background:var(--card); }
    .site-card .url { display:flex; align-items:center; gap:.5rem; }
    .pill { padding:.2rem .5rem; border-radius:999px; font-size:.875rem; }
    .pill.up { background:#e8f7ee; color:#207d41; }
    .pill.down { background:#fde8e8; color:#b42318; }
    .empty { margin-top:1rem; padding:1rem; background:#fff8db; border:1px solid #ffe08a; border-radius:.5rem; display:none; }
  </style>
</head>
<body>

  <header class="sites-header">
    <div>URL</div><div>Status</div><div>Response</div><div>Uptime</div>
  </header>

  <section id="sites" class="sites"></section>
  <div id="empty" class="empty">No data yet. When GitHub Pages publishes <code>history/summary.json</code> and <code>api/</code>, this will populate.</div>

  <script>
    // --- auto-detect base path: works for /upptime/, /uptime/, or custom domain ---
    function detectBase() {
      const segs = location.pathname.split("/").filter(Boolean);
      if (location.hostname.endsWith("github.io") && segs.length) return "/" + segs[0] + "/"; // e.g. "/upptime/"
      return "/";
    }
    const BASE = detectBase();
    const SUMMARY_URL = BASE + "history/summary.json";
    const API_BASE    = BASE + "api/";

    // Quiet fetch (no console noise)
    async function fetchJson(url) {
      try { const r = await fetch(url, { cache: "no-store" }); if (!r.ok) return null; return await r.json(); }
      catch { return null; }
    }

    // helpers
    const last = (arr) => (Array.isArray(arr) && arr.length ? arr[arr.length - 1] : null);

    // read response-time from either series JSON or badge JSON
    function extractResponseMs(obj) {
      if (obj == null) return null;
      // badge style: { schemaVersion, label: "response time", message: "1195 ms" }
      if (obj.schemaVersion && typeof obj.message === "string") {
        const m = obj.message.match(/([\d.]+)/);
        return m ? Number(m[1]) : null;
      }
      // series style
      if (typeof obj === "number") return obj;
      if (typeof obj.average === "number") return obj.average;
      if (typeof obj.median === "number") return obj.median;
      if (typeof obj.last24h === "number") return obj.last24h;
      if (obj.daily)   { const d = last(obj.daily);   if (d && typeof d.value === "number") return d.value; }
      if (obj.weekly)  { const d = last(obj.weekly);  if (d && typeof d.value === "number") return d.value; }
      if (obj.monthly) { const d = last(obj.monthly); if (d && typeof d.value === "number") return d.value; }
      if (Array.isArray(obj) && typeof last(obj)?.value === "number") return last(obj).value;
      return null;
    }

    // read uptime from either series JSON or badge JSON
    function extractUptimePct(obj) {
      if (obj == null) return null;
      // badge style: { schemaVersion, label: "uptime", message: "99.94%" }
      if (obj.schemaVersion && typeof obj.message === "string") {
        const m = obj.message.match(/([\d.]+)/);
        return m ? Number(m[1]) : null;
      }
      // series style
      if (typeof obj === "number") return obj;
      if (typeof obj.uptime === "number") return obj.uptime;
      if (typeof obj.overall === "number") return obj.overall;
      if (obj.daily)   { const d = last(obj.daily);   if (d && typeof d.uptime === "number") return d.uptime; }
      if (obj.weekly)  { const d = last(obj.weekly);  if (d && typeof d.uptime === "number") return d.uptime; }
      if (obj.monthly) { const d = last(obj.monthly); if (d && typeof d.uptime === "number") return d.uptime; }
      if (Array.isArray(obj) && typeof last(obj)?.uptime === "number") return last(obj).uptime;
      return null;
    }

    function pill(isUp) {
      const s = document.createElement("span");
      s.className = "pill " + (isUp ? "up" : "down");
      s.textContent = isUp ? "Up" : "Down";
      return s;
    }

    function renderCard(container, site, metrics) {
      const el = document.createElement("article");
      el.className = "site-card";

      const url = document.createElement("div");
      url.className = "url";
      const fav = document.createElement("img"); fav.height = 13; fav.alt = "";
      const a = document.createElement("a");
      if (site.url) {
        try { fav.src = "https://icons.duckduckgo.com/ip3/" + new URL(site.url).host + ".ico"; } catch {}
        a.href = site.url;
      }
      a.textContent = site.name || site.url || site.slug || "—";
      url.append(fav, a);

      const status = document.createElement("div"); status.className = "status";
      const s = String(site.status || "").toLowerCase();
      if (s === "up" || s === "down") status.appendChild(pill(s === "up")); else status.textContent = "—";

      const response = document.createElement("div"); response.className = "response";
      const ms = (typeof metrics.responseMs === "number") ? Math.round(metrics.responseMs) : null;
      response.textContent = (ms != null && isFinite(ms)) ? `${ms} ms` : "—";

      const uptime = document.createElement("div"); uptime.className = "uptime";
      const pct = (typeof metrics.uptimePct === "number") ? metrics.uptimePct : null;
      uptime.textContent = (pct != null && isFinite(pct)) ? `${pct.toFixed(2)}%` : "—";

      el.append(url, status, response, uptime);
      container.appendChild(el);
    }

    async function loadPerSite(slug) {
      const respFiles = ["response-time.json","response-time-day.json","response-time-week.json","response-time-month.json","response-time-year.json"];
      const upFiles   = ["uptime.json","uptime-day.json","uptime-week.json","uptime-month.json","uptime-year.json"];
      let responseMs = null, uptimePct = null;

      for (const f of respFiles) {
        const j = await fetchJson(API_BASE + slug + "/" + f);
        const v = extractResponseMs(j);
        if (typeof v === "number") { responseMs = v; break; }
      }
      for (const f of upFiles) {
        const j = await fetchJson(API_BASE + slug + "/" + f);
        const v = extractUptimePct(j);
        if (typeof v === "number") { uptimePct = v; break; }
      }
      return { responseMs, uptimePct };
    }

    (async function init() {
      const list = document.getElementById("sites");
      const empty = document.getElementById("empty");

      // 1) Load site list + status
      const summary = await fetchJson(SUMMARY_URL);
      if (!summary) { empty.style.display = "block"; return; }
      const rows = Array.isArray(summary) ? summary : (summary.sites || []);
      if (!rows.length) { empty.style.display = "block"; return; }

      // 2) For each site, pull metrics from /api/<slug>/… (handles badge JSON too)
      for (const s of rows) {
        const site = {
          slug: s.slug,
          name: s.name || s.title || s.slug,
          url:  s.url  || s.site  || "",
          status: s.status
        };
        const metrics = await loadPerSite(site.slug);
        renderCard(list, site, metrics);
      }
    })();
  </script>
</body>
</html>
