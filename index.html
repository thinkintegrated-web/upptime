<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Think Integrated Upptime</title>
  <style>
    :root { --bg:#fafafa; --text:#222; --card:#fff; --br:#e3e6ea; --hdr:#f6f7f9; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; background: var(--bg); color: var(--text); }
    h1 { margin: 0 0 1rem; font-size: 1.5rem; }
    .group-title { margin: 2rem 0 .5rem; font-size: 1.125rem; font-weight: 700; }
    .grid { display: grid; gap: .75rem; }
    .header { padding: .75rem 1rem; background: var(--hdr); border: 1px solid var(--br); border-radius: .5rem; font-weight: 600; }
    .card { display: grid; grid-template-columns: 1.6fr .6fr .6fr .8fr; gap: .75rem; align-items: center;
            padding: 1rem; background: var(--card); border: 1px solid var(--br); border-radius: .75rem; }
    .url { display: flex; align-items: center; gap: .5rem; min-width: 0; }
    .url a { color: #1f6feb; text-decoration: none; }
    .url a:hover { text-decoration: underline; }
    .pill { padding: .2rem .5rem; border-radius: 999px; font-size: .875rem; }
    .pill.up { background: #e8f7ee; color: #207d41; }
    .pill.down { background: #fde8e8; color: #b42318; }
    .empty { display:none; margin-top:1rem; padding:1rem; background:#fff8db; border:1px solid #ffe08a; border-radius:.5rem; }
    img.fav { width: 13px; height: 13px; }
  </style>
</head>
<body>

  <h1>Think Integrated Upptime</h1>

  <div id="groups"></div>

  <div id="headerTpl" class="grid cols-4 header" style="display:none">
    <div>URL</div><div>Status</div><div>Response</div><div>Uptime</div>
  </div>

  <div id="empty" class="empty">No data yet. Once GitHub Pages publishes <code>history/summary.json</code> and <code>api/</code>, this will populate automatically.</div>

  <script>
    /* ------------ base + repo config ------------ */
    function detectBase() {
      const segs = location.pathname.split("/").filter(Boolean);
      if (location.hostname.endsWith("github.io") && segs.length) return "/" + segs[0] + "/"; // /upptime/
      return "/";
    }
    const BASE = detectBase();                                // e.g. "/upptime/"
    const SUMMARY_URL = BASE + "history/summary.json";
    const API_BASE    = BASE + "api/";
    const GROUPS_JSON = BASE + "assets/groups.json";          // public file we can serve

    // raw .upptimerc.yml fallback (works if repo public)
    const OWNER="thinkintegrated-web", REPO="upptime", BRANCH="master";
    const RC_RAW = `https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH}/.upptimerc.yml`;

    /* ------------ fetch helpers ------------ */
    async function fetchJson(url){ try{ const r=await fetch(url,{cache:"no-store"}); if(!r.ok) return null; return await r.json(); }catch{return null;} }
    async function fetchText(url){ try{ const r=await fetch(url,{cache:"no-store"}); if(!r.ok) return null; return await r.text(); }catch{return null;} }

    /* ------------ url/slug helpers ------------ */
    function getHost(u){ try{ return new URL(u).host.toLowerCase().replace(/^www\./,""); }catch{ return null; } }
    function slugFromUrl(u){ const h=getHost(u); return h ? h.replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"") : null; }

    /* ------------ parse .upptimerc.yml (fallback) ------------ */
    function parseRcYml(yml){
      const rows=[]; const lines=yml.split(/\r?\n/);
      let inSites=false, cur=null;
      for(const raw of lines){
        const line=raw.replace(/\t/g,"  ");
        if(!inSites){ if(/^\s*sites\s*:\s*$/.test(line)) inSites=true; continue; }
        if(/^\S/.test(line)) break;
        if(/^\s*-\s*/.test(line)){ if(cur) rows.push(cur); cur={}; continue; }
        if(!cur) continue;
        const m=/^\s*(name|url|group|alias)\s*:\s*(.+)\s*$/.exec(line);
        if(m){ const k=m[1]; let v=m[2].trim().replace(/^["']|["']$/g,""); cur[k]=v; }
      }
      if(cur) rows.push(cur);
      return rows;
    }

    /* ------------ metric extractors (badge or series) ------------ */
    const last=(a)=>Array.isArray(a)&&a.length?a[a.length-1]:null;

    function extractResponseMs(obj){
      if(!obj) return null;
      if(obj.schemaVersion && typeof obj.message==="string"){ const m=obj.message.match(/([\d.]+)/); return m?Number(m[1]):null; }
      if(typeof obj==="number") return obj;
      if(typeof obj.average==="number") return obj.average;
      if(typeof obj.median==="number")  return obj.median;
      if(typeof obj.last24h==="number") return obj.last24h;
      if(obj.daily){ const d=last(obj.daily); if(d&&typeof d.value==="number") return d.value; }
      if(obj.weekly){const d=last(obj.weekly);if(d&&typeof d.value==="number") return d.value;}
      if(obj.monthly){const d=last(obj.monthly);if(d&&typeof d.value==="number") return d.value;}
      if(Array.isArray(obj)&&typeof last(obj)?.value==="number") return last(obj).value;
      return null;
    }

    function extractUptimePct(obj){
      if(!obj) return null;
      if(obj.schemaVersion && typeof obj.message==="string"){ const m=obj.message.match(/([\d.]+)/); return m?Number(m[1]):null; }
      if(typeof obj==="number") return obj;
      if(typeof obj.uptime==="number") return obj.uptime;
      if(typeof obj.overall==="number") return obj.overall;
      if(obj.daily){ const d=last(obj.daily); if(d&&typeof d.uptime==="number") return d.uptime; }
      if(obj.weekly){const d=last(obj.weekly);if(d&&typeof d.uptime==="number") return d.uptime;}
      if(obj.monthly){const d=last(obj.monthly);if(d&&typeof d.uptime==="number") return d.uptime;}
      if(Array.isArray(obj)&&typeof last(obj)?.uptime==="number") return last(obj).uptime;
      return null;
    }

    /* ------------ UI helpers ------------ */
    function pill(isUp){ const s=document.createElement("span"); s.className="pill "+(isUp?"up":"down"); s.textContent=isUp?"Up":"Down"; return s; }

    function renderCard(container, site, metrics){
      const el=document.createElement("article"); el.className="card";
      const url=document.createElement("div"); url.className="url";
      const fav=document.createElement("img"); fav.className="fav"; fav.alt="";
      const a=document.createElement("a");
      if(site.url){ try{ fav.src="https://icons.duckduckgo.com/ip3/"+new URL(site.url).host+".ico"; }catch{} a.href=site.url; }
      let label = site.name;
      if (!label && site.url) {
        try { label = new URL(site.url).host.replace(/^www\./, ""); } catch {}
      }
      a.textContent = label || site.slug || "—";
      url.append(fav,a);

      const status=document.createElement("div");
      const s=String(site.status||"").toLowerCase(); (s==="up"||s==="down")?status.appendChild(pill(s==="up")):status.append("—");

      const response=document.createElement("div");
      const ms= (typeof metrics.responseMs==="number")?Math.round(metrics.responseMs):null;
      response.textContent=(ms!=null&&isFinite(ms))?`${ms} ms`:"—";

      const uptime=document.createElement("div");
      const pct=(typeof metrics.uptimePct==="number")?metrics.uptimePct:null;
      uptime.textContent=(pct!=null&&isFinite(pct))?`${pct.toFixed(2)}%`:"—";

      el.append(url,status,response,uptime);
      container.appendChild(el);
    }

    async function loadPerSite(slug){
      const respFiles=["response-time.json","response-time-day.json","response-time-week.json","response-time-month.json","response-time-year.json"];
      const upFiles=["uptime.json","uptime-day.json","uptime-week.json","uptime-month.json","uptime-year.json"];
      let responseMs=null, uptimePct=null;

      for(const f of respFiles){ const j=await fetchJson(API_BASE+slug+"/"+f); const v=extractResponseMs(j); if(typeof v==="number"){ responseMs=v; break; } }
      for(const f of upFiles){ const j=await fetchJson(API_BASE+slug+"/"+f); const v=extractUptimePct(j); if(typeof v==="number"){ uptimePct=v; break; } }
      return { responseMs, uptimePct };
    }

    /* ------------ Main ------------ */
    (async function init(){
      const groupsRoot=document.getElementById("groups");
      const empty=document.getElementById("empty");
      const headerTpl=document.getElementById("headerTpl");

      // 1) Load sites list + status
      const summary=await fetchJson(SUMMARY_URL);
      if(!summary){ empty.style.display="block"; return; }
      const rows=Array.isArray(summary)?summary:(summary.sites||[]);
      if(!rows.length){ empty.style.display="block"; return; }

      // 2) Build metadata map: try public assets/groups.json first, then raw .upptimerc.yml
      let groupByHost = await fetchJson(GROUPS_JSON); // { host: "group" }
      let metaBySlug={}, metaByHost={};

      if (groupByHost && typeof groupByHost === "object") {
        // Use public JSON directly
        for (const [host, group] of Object.entries(groupByHost)) {
          metaByHost[host.toLowerCase()] = { group }; // no alias here
        }
      } else {
        // Fallback: raw .upptimerc.yml (works if repo is public)
        const rcText = await fetchText(RC_RAW);
        if (rcText) {
          for (const r of parseRcYml(rcText)) {
            if (!r.url) continue;
            const host = getHost(r.url);
            const slug = slugFromUrl(r.url);
            const meta = { group: r.group || r.alias, alias: r.alias };
            if (slug) metaBySlug[slug] = meta;
            if (host) metaByHost[host] = meta;
          }
        }
      }

      // 3) Group sites (slug → meta, else host → meta, else "Other")
      const groups=new Map();
      for(const s of rows){
        const host=getHost(s.url||s.site||"");
        const slug=s.slug;
        const meta=(metaBySlug[slug])||(host?metaByHost[host]:null)||{};
        const groupName=meta.group||"Other";

        if(!groups.has(groupName)) groups.set(groupName,{name:groupName,items:[]});
        groups.get(groupName).items.push({
          slug,
          name: s.name || s.title || slug,
          url:  s.url || s.site || "",
          status: s.status
        });
      }

      // 4) Render
      for(const [,g] of groups){
        const title=document.createElement("div");
        title.className="group-title";
        title.textContent=g.name;

        const hdr=headerTpl.cloneNode(true); hdr.style.display=""; hdr.classList.add("grid","cols-4");
        const list=document.createElement("section"); list.className="grid cols-cards";

        groupsRoot.append(title,hdr,list);

        for(const site of g.items){
          const metrics=await loadPerSite(site.slug);
          renderCard(list, site, metrics);
        }
      }
    })();
  </script>
</body>
</html>
